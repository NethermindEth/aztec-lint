use std::collections::{BTreeMap, BTreeSet};

use crate::common::{
    DynError, ensure_no_unknown_options, optional_option, parse_flags_and_options, read_text_file,
    workspace_root, write_text_file,
};

const GENERATED_START: &str = "<!-- generated:lint-intake:start -->";
const GENERATED_END: &str = "<!-- generated:lint-intake:end -->";

#[derive(Clone)]
struct IntakeEntry {
    proposal: String,
    status: String,
    canonical_mapping: String,
    notes: String,
}

pub fn run(args: &[String]) -> Result<(), DynError> {
    let (mut flags, mut options) = parse_flags_and_options(args)?;
    let check = flags.remove("check");
    let source =
        optional_option(&mut options, "source").ok_or("missing required option '--source'")?;
    ensure_no_unknown_options(&flags, &options)?;

    let root = workspace_root()?;
    let source_path = root.join(source);
    let source_text = read_text_file(&source_path)?;
    let entries = parse_intake_table(&source_text)?;
    validate_entries(&entries)?;

    let target_path = root.join("docs/rule-roadmap.md");
    let existing = if target_path.exists() {
        read_text_file(&target_path)?
    } else {
        String::new()
    };

    let generated_block = render_generated_block(&entries);
    let next = merge_generated_block(existing.as_str(), generated_block.as_str());

    if check {
        if existing != next {
            return Err(
                "docs/rule-roadmap.md is out of date; run `cargo xtask lint-intake --source docs/NEW_LINTS.md`"
                    .into(),
            );
        }
        println!("lint-intake check: docs/rule-roadmap.md is in sync");
        return Ok(());
    }

    write_text_file(&target_path, &next)?;
    println!("lint-intake: updated {}", target_path.display());
    Ok(())
}

fn parse_intake_table(source: &str) -> Result<Vec<IntakeEntry>, DynError> {
    let mut lines = source.lines();
    let header = "| Proposal | Status | Canonical mapping | Notes |";

    while let Some(line) = lines.next() {
        if line.trim() != header {
            continue;
        }

        let mut entries = Vec::<IntakeEntry>::new();
        for row in lines.by_ref() {
            let trimmed = row.trim();
            if !trimmed.starts_with('|') {
                break;
            }
            if trimmed.starts_with("|---") {
                continue;
            }
            let cells = trimmed
                .split('|')
                .map(str::trim)
                .filter(|cell| !cell.is_empty())
                .collect::<Vec<_>>();
            if cells.len() != 4 {
                return Err(format!("invalid lint intake row: '{trimmed}'").into());
            }
            entries.push(IntakeEntry {
                proposal: cells[0].to_string(),
                status: cells[1].to_string(),
                canonical_mapping: cells[2].to_string(),
                notes: cells[3].to_string(),
            });
        }

        if entries.is_empty() {
            return Err("lint intake table is present but has no rows".into());
        }
        return Ok(entries);
    }

    Err("could not find lint intake table in source markdown".into())
}

fn validate_entries(entries: &[IntakeEntry]) -> Result<(), DynError> {
    let allowed = ["`covered`", "`accepted`", "`deferred`", "`rejected`"];
    let mut seen = BTreeSet::<String>::new();
    for entry in entries {
        if !allowed.contains(&entry.status.as_str()) {
            return Err(format!(
                "unsupported intake status '{}' for proposal {}",
                entry.status, entry.proposal
            )
            .into());
        }
        if !seen.insert(entry.proposal.clone()) {
            return Err(format!(
                "duplicate proposal '{}' in lint intake table",
                entry.proposal
            )
            .into());
        }
    }
    Ok(())
}

fn render_generated_block(entries: &[IntakeEntry]) -> String {
    let mut counts = BTreeMap::<String, usize>::new();
    for entry in entries {
        *counts.entry(entry.status.clone()).or_insert(0usize) += 1;
    }

    let mut out = String::new();
    out.push_str(GENERATED_START);
    out.push('\n');
    out.push_str("## Suggestion Intake Mapping\n\n");
    out.push_str("Generated by `cargo xtask lint-intake --source docs/NEW_LINTS.md`.\n\n");
    out.push_str("Status counts:\n");
    for status in ["`covered`", "`accepted`", "`deferred`", "`rejected`"] {
        let count = counts.get(status).copied().unwrap_or(0usize);
        out.push_str(&format!("- {status}: {count}\n"));
    }
    out.push('\n');
    out.push_str("| Proposal | Status | Canonical mapping | Notes |\n");
    out.push_str("|---|---|---|---|\n");
    for entry in entries {
        out.push_str(&format!(
            "| {} | {} | {} | {} |\n",
            entry.proposal, entry.status, entry.canonical_mapping, entry.notes
        ));
    }
    out.push('\n');
    out.push_str(GENERATED_END);
    out.push('\n');
    out
}

fn merge_generated_block(existing: &str, generated: &str) -> String {
    if existing.is_empty() {
        let mut fresh = String::new();
        fresh.push_str("# Rule Roadmap\n\n");
        fresh.push_str("This roadmap tracks planned lint growth and intake decisions.\n\n");
        fresh.push_str(generated);
        return fresh;
    }

    if let (Some(start), Some(end)) = (existing.find(GENERATED_START), existing.find(GENERATED_END))
    {
        let mut merged = String::new();
        merged.push_str(&existing[..start]);
        merged.push_str(generated);
        let tail_start = end + GENERATED_END.len();
        let tail = &existing[tail_start..];
        if !tail.trim().is_empty() {
            if !tail.starts_with('\n') {
                merged.push('\n');
            }
            merged.push_str(tail.trim_start_matches('\n'));
        }
        return merged;
    }

    let mut merged = existing.to_string();
    if !merged.ends_with('\n') {
        merged.push('\n');
    }
    merged.push('\n');
    merged.push_str(generated);
    merged
}
